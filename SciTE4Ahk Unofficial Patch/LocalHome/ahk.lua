-- ahk.lua
-- =======

-- Part of SciTE4AutoHotkey
-- This file implements features specific to AutoHotkey in SciTE
-- Do NOT edit this file, use UserLuaScript.lua instead!

-- Functions:
--     AutoIndent for AutoHotkey
--     Some AutoComplete tweaks
--     Automatic backups
--     SciTEDebug.ahk DBGp debugger interface

local prepared = false
local savedbk = nil

-- ================================================== --
-- JANGOON's Unofficial Patch - Global variables
-- ================================================== --

-- Ignore Styles
local ignoreStylesTable = {
	[SCLEX_AHK1] = {SCE_AHK_COMMENTLINE, SCE_AHK_COMMENTBLOCK, SCE_AHK_STRING, SCE_AHK_ERROR, SCE_AHK_ESCAPE},
	[SCLEX_AHK2] = {SCE_AHK2_COMMENTLINE, SCE_AHK2_COMMENTBLOCK, SCE_AHK2_STRING, SCE_AHK2_ERROR, SCE_AHK2_ESCAPE},
}

-- Parenthesis Auto Indent
local NoCalltip = false
local SetSel = false
local SelStart = 0
local SelEnd = 0

-- Avoid errors in OnChar events (Foreign Language)
local curKey = ""

-- Word Highlight
local HighlightLine = {}
local HighlightPos = 0

-- Realtime User Define Function 
local Define_Funcs = {}

-- Auto Complete
local IGNORE_CASE = true
local MIN_PREFIX_LEN = tonumber(props['autocomplete.define.prefix'])
local MIN_IDENTIFIER_LEN = tonumber(props['autocomplete.define.identifier'])
local IDENTIFIER_PATTERNS = {"[%a_][%w_]+", "[%a_][%w_.]*[%w_]", "[%a_][%w_-]*[%w_]"}
local names = {}
local notempty = next

if IGNORE_CASE then
	normalize = string.lower
else
	normalize = function(word) return word end
end

function buildNames()
	names = {}
	local text = editor:GetText()
	for i, pattern in ipairs(IDENTIFIER_PATTERNS) do
		for word in string.gmatch(text, pattern) do
			if string.len(word) >= MIN_IDENTIFIER_LEN then
				names[word] = true
			end
		end
	end
end

-- ================================================== --
-- OnClear event - fired when SciTE changes documents --
-- ================================================== --

function OnClear()
	if not prepared then
		-- Remove the current line markers.
		ClearAllMarkers()
	end
	
	SetMarkerColors()
	editor.MarginSensitiveN[1] = true
end

-- ================================================== --
-- OnUpdateUI event
-- ================================================== --

function OnUpdateUI()
	if editor.TextLength == 0 then
		if props['FilePath'] ~= props['SciteUserHome'] .. "\\template.ahk" then
			local file = io.open(props['SciteUserHome'] .. "/template.ahk", "r")
			if file ~= nil then
				local txt = file:read("*a")
				if txt ~= "" then editor:SetText(txt) end file:close()
			end
		end
	end

	local curPos = editor.CurrentPos
	RTcurChar = str(editor.CharAt[curPos])
	RTprevChar = str(editor.CharAt[curPos-1])
	
	if HighlightPos ~= curPos or editor:MarkerGet(editor:LineFromPosition(curPos)) == 0 then
		if editor:IndicatorValueAt(9, curPos) == 1 or editor:IndicatorValueAt(9, curPos - 1) == 1 then
			HighlightLine = {}
			local n = 1
			local limit = editor.TextLength
			while true do
				if editor:IndicatorValueAt(9, n) == 1 then
					local ThisLine = editor:LineFromPosition(n)
					HighlightLine[ThisLine] = true
					n = editor:PositionFromLine(ThisLine + 1)
				else
					n = n + 1
				end
				if n >= limit then
					break
				end
			end
			for i, _ in pairs(HighlightLine) do
				editor:MarkerAdd(i, 4)
			end
			HighlightPos = curPos
		else
			editor:MarkerDeleteAll(4)
			HighlightPos = 0
		end
	end
end

-- ====================================== --
-- OnChar event - needed by some features --
-- ====================================== --

function OnChar(curChar)
	-- This function should only run when the Editor pane is focused.
	if not editor.Focus then return false end
	-- This function only works with the AutoHotkey lexer
	if not InAHKLexer() then return false end
	
	local ignoreStyles = ignoreStylesTable[editor.Lexer]
	local IgnoreChar = {"\n", "{", "}", "(", ")", "[", "]", ",", ".", "=", "'", '"'}

	if isInTable(IgnoreChar, curChar) then
		buildNames()
	end

	if curChar == "\n" then
		local prevStyle = editor.StyleAt[getPrevLinePos()]
		if not isInTable(ignoreStyles, prevStyle) then
			return AutoIndent_OnNewLine()
		end
	elseif isInTable({"(", "{", "["}, curChar) then
		if curKey == curChar then
			editor:Undo()
			if SetSel then editor:SetSel(SelStart, SelEnd) SetSel=false end
		end
	elseif isInTable({")", "}", "]"}, curChar) then
		if curKey == curChar then
			local curStyle = editor.StyleAt[editor.CurrentPos]
			if not isInTable(ignoreStyles, curStyle) then
				local curPos = editor.CurrentPos
				if editor:BraceMatch(curPos, 0) >= 0 then
					editor:DeleteBack() editor:GotoPos(curPos)
				end
			end
			if curChar == "}" then
				curStyle = editor.StyleAt[editor.CurrentPos-2]
				if not isInTable(ignoreStyles, curStyle) then
					AutoIndent_OnClosingBrace()
				end
			end
		end
	elseif curChar == "," and curKey == "," then
		local curStyle = editor.StyleAt[editor.CurrentPos]
		if not isInTable(ignoreStyles, curStyle) then
			editor:AddText(" ")
		end
	else
		local curStyle = editor.StyleAt[editor.CurrentPos-2]
		local pos = editor:WordStartPosition(editor.CurrentPos)
		
		-- Disable AutoComplete on comment/string/error/etc.
		if isInTable(ignoreStyles, curStyle) then
			-- ... but allow it in variable %dereferences% (which are set to 'error'
			-- when they are typed because of the missing closing percent sign.
			if not IsAHKv2() and curStyle == SCE_AHK_ERROR and editor.CharAt[pos-1] == 37
			  and not isInTable(ignoreStyles, editor.StyleAt[pos-1]) then
				return false
			end
			return CancelAutoComplete()
		end
		curStyle = editor.StyleAt[editor.CurrentPos]
		local prevChar = str(editor.CharAt[editor.CurrentPos - 2])
		if curChar ~= " " and prevChar == "," then
			if not isInTable(ignoreStyles, curStyle) then
				editor:DeleteBack()
				editor:AddText(" " .. curChar)
			end
		end
	end
	if not editor:AutoCActive() and NoCalltip == false then
		editor.AutoCIgnoreCase = IGNORE_CASE
		local pos = editor.CurrentPos
		local startPos = editor:WordStartPosition(pos, true)
		local len = pos - startPos
		if len >= MIN_PREFIX_LEN then
			local prefix = editor:textrange(startPos, pos)
			local menuItems = {}
			for name, v in pairs(names) do
				if normalize(string.sub(name, 1, len)) == normalize(prefix) then 
					table.insert(menuItems, name)
				end
			end
			if notempty(menuItems) then
				table.sort(menuItems)
				editor:AutoCShow(len, table.concat(menuItems, " "))
			end
		end
	end	
	return false
end

function CancelAutoComplete()
	if editor:AutoCActive() then
		editor:AutoCCancel()
	end
	return true
end

-- ====================================== --
-- OnKey event
-- ====================================== --

function OnKey(key, Shift)
	if not InAHKLexer() then return false end
	if key == 8 then
		local ignoreStyles = ignoreStylesTable[editor.Lexer]
		local curPos = editor.CurrentPos
		if #editor:GetSelText() == 0
			and isInTable(ignoreStyles, editor.StyleAt[curPos - 1]) == false then
			if isInTable({"(", ")", "{", "}", "[", "]"}, RTprevChar) then
				DelEmptyParenthesis(RTprevChar, curPos - 1, curPos)
			elseif isInTable({" ", "	", "\r", "\n"}, RTprevChar) then
				editor:SearchAnchor()
				local CharPos = editor:SearchPrev(SCFIND_REGEXP, "[^ 	\r\n]")
				local OpenPos = editor:SearchPrev(SCFIND_REGEXP, "[({\[]")
				if OpenPos >= 0 and CharPos == OpenPos and isInTable(ignoreStyles, editor.StyleAt[OpenPos]) == false then
					DelEmptyParenthesis(str(editor.CharAt[OpenPos]), OpenPos, curPos)
				else
					editor:GotoPos(curPos)
				end
			end
		end
	elseif key == 57 and Shift == true then
		NoCalltip = false
		OnParenthesis(0)
		curKey = "("
	elseif key == 219 then
		if Shift then
			OnParenthesis(1)
			curKey = "{"
		else
			OnParenthesis(2)
			curKey = "["
		end
	elseif key == 48 and Shift == true then
		curKey = ")"
	elseif key == 221 then
		if Shift then
			curKey = "}"
		else
			curKey = "]"
		end
	elseif key == 188 and Shift == false then
		curKey = ","
	elseif key == 13 then
		curKey = "\n"
	else
		curKey = ""
	end
end

function DelEmptyParenthesis(DelChar, CharPos, curPos)
	local OpenPos = CharPos
	local ClosePos = editor:BraceMatch(OpenPos, 0)
	local Add = 1
	if OpenPos > ClosePos then
		OpenPos = ClosePos
		ClosePos = CharPos
		Add = 0
	end
	local text = editor:textrange(OpenPos + 1, ClosePos)
	if #text == 0 or string.find(text, "%S") == nil then
		editor:DeleteRange(OpenPos + Add, ClosePos - OpenPos)
	elseif CharPos ~= 0 then
		editor:GotoPos(curPos)
	end
end

-- ================================================== --
-- Parenthesis Auto Indent
-- ================================================== --

function OnParenthesis(thisCase)
	local thisChar = "(" local pairChar = ")"
	if thisCase == 1 then thisChar = "{" pairChar = "}"
	elseif thisCase == 2 then thisChar = "[" pairChar = "]" end
	local ignoreStyles = ignoreStylesTable[editor.Lexer]
	local curPos = editor.CurrentPos
	local Selected_Text = editor:GetSelText()
	editor:BeginUndoAction()
	if IgnoreCase(curPos) or IgnoreCase(editor.Anchor) then
		editor:ReplaceSel(thisChar)
	else
		if #Selected_Text == 0 then
			if thisCase == 1 then
				local curLineNum = editor:LineFromPosition(curPos)
				local curLinePos = editor:PositionFromLine(curLineNum)
				local curText = editor:textrange(curLinePos, curPos)
				local prevLineNum = curLineNum - 1
				local prevLineText = editor:GetLine(prevLineNum)
				local BraceCase = 0
				local BlockNewLine = false
				local IndentSpace = ""
				if string.find(curText, "^%s*$") then
					BraceCase = CaseCheck(prevLineText)
					BlockNewLine = true
					IndentSpace = string.gsub(prevLineText, "^(%s*).*", "%1")
				else
					BraceCase = CaseCheck(curText)
					IndentSpace = string.gsub(curText, "^(%s*).*", "%1")
				end
				if BraceCase == 0 then
					editor:AddText("{}")
					editor:GotoPos(editor.CurrentPos - 1)
				else
					if BlockNewLine == true then
						editor:HomeExtend() editor:AddText(IndentSpace .. "{") editor:NewLine()
					else
						if BraceCase == 2 then
							editor:AddText("\r\n" .. IndentSpace .. "{\r\n" .. IndentSpace .. "	")
						else
							editor:AddText("{\r\n" .. IndentSpace .. "	")
						end
					end
					local ComebackPos = editor.CurrentPos
					if BraceCase == 2 then
						editor:AddText("Case ")
						ComebackPos = editor.CurrentPos
					elseif BraceCase == 3 then
						editor:AddText("/* write your calltip here") editor:NewLine()
						editor:NewLine() editor:AddText("*/") editor:NewLine()
						ComebackPos = editor.CurrentPos
					end
					editor:AddText("\r\n" .. IndentSpace .. "}") editor:GotoPos(ComebackPos)
				end
			else
				local curChar = str(editor.CharAt[editor.CurrentPos])
				if string.find(str(editor.CharAt[curPos]), "[%s%W]") or curChar == "" then
					editor:InsertText(curPos, pairChar) editor:AddText(thisChar)
				else editor:AddText(thisChar)
				end
				if thisCase == 0 then
					scite.MenuCommand(IDM_SHOWCALLTIP)
					if editor:CallTipActive() == false then
						local curPos = editor.CurrentPos - 1
						local WordStartPos = editor:WordStartPosition(curPos)
						local curWord = editor:textrange(WordStartPos, curPos)
						if keyInTable(Define_Funcs, curWord) then
							editor:CallTipShow(WordStartPos, Define_Funcs[curWord])
						end
					end
				end
			end
		else
			SetSel = true NoCalltip = true
			local SelStartPos = editor.SelectionStart
			local SelEndPos = editor.SelectionEnd
			local SelStartLine = editor:LineFromPosition(SelStartPos)
			local SelEndLine = editor:LineFromPosition(SelEndPos)
			if thisCase == 2 or string.find(Selected_Text, "\n") == nil then
				if thisCase == 1 then
					local curLineNum = editor:LineFromPosition(curPos)
					local prevLineText = editor:GetLine(curLineNum - 1)
					if isStartBlockStatement(prevLineText) then
						IndentSpace = string.gsub(prevLineText, "^(%s*).*", "%1")
					else
						IndentSpace = string.gsub(editor:GetLine(curLineNum), "^(%s*).*", "%1")
					end
					editor:SetSel(editor:PositionFromLine(curLineNum), editor.LineEndPosition[curLineNum])
					editor:ReplaceSel(IndentSpace .. "{\r\n	" .. IndentSpace
						.. string.gsub(editor:textrange(editor.LineIndentPosition[curLineNum], editor.LineEndPosition[curLineNum])
						, "\n", "\n	") .. "\r\n" .. IndentSpace .. "}")
					SelStart = editor:PositionFromLine(curLineNum + 1)
					SelEnd = editor.LineEndPosition[curLineNum + 1]
				else
					editor:InsertText(SelEndPos, pairChar)
					editor:InsertText(SelStartPos, thisChar)
					if curPos == SelEndPos then
						SelStart = SelStartPos + 1
						SelEnd = SelEndPos + 1
					else
						SelStart = SelEndPos + 1
						SelEnd = SelStartPos + 1
					end
				end
			else
				local MinIndentSpace = GetMinIndent(SelStartLine, SelEndLine)
				if thisCase == 0 then
					editor:InsertText(editor:PositionFromLine(SelEndLine + 1), MinIndentSpace .. pairChar .. "\r\n")
					editor:InsertText(editor:PositionFromLine(SelStartLine), MinIndentSpace .. thisChar .. "\r\n")
				else
					local prevLineText = editor:GetLine(SelStartLine - 1)
					editor:SetSel(editor:PositionFromLine(SelStartLine), editor.LineEndPosition[SelEndLine])
					if isStartBlockStatement(prevLineText) then
						local IndentSpace = string.gsub(prevLineText, "^(%s*).*", "%1")
						editor:ReplaceSel(IndentSpace .. "{\r\n"
							.. string.gsub(string.gsub(editor:GetSelText(), "^" .. MinIndentSpace, "	" .. IndentSpace)
							, "\n" .. MinIndentSpace, "\n	" .. IndentSpace) .. "\r\n" .. IndentSpace .. "}")
					else
						editor:ReplaceSel(MinIndentSpace .. "{\r\n"
							.. string.gsub(string.gsub(editor:GetSelText(), "^" .. MinIndentSpace, "	" .. MinIndentSpace)
							, "\n" .. MinIndentSpace, "\n	" .. MinIndentSpace) .. "\r\n" .. MinIndentSpace .. "}")
					end
				end
				SelStart = editor:PositionFromLine(SelStartLine + 1)
				SelEnd = editor.LineEndPosition[SelEndLine + 1]
			end
		end
	end
	editor:EndUndoAction()
end

function IgnoreCase(curPos)
	local ignoreStyles = ignoreStylesTable[editor.Lexer]
	if isInTable(ignoreStyles, editor.StyleAt[curPos]) then
		if isInTable(ignoreStyles, editor.StyleAt[curPos - 1]) then return true
		else return false end
	end
end

function CaseCheck(line)
	if isStartBlockStatement(line) then return 1
	elseif isSwitchLine(line) then return 2
	elseif isFunctionLine(line) then return 3
	else return 0
	end
end

function GetMinIndent(StartLine, EndLine)
	local MinIndentation = 1024
	local MinIndentSpace = ""
	local curWhileLine = StartLine
	local curIndent = 0
	while curWhileLine <= EndLine do
		curIndent = editor.LineIndentation[curWhileLine]
		if curIndent < MinIndentation then
			MinIndentation = curIndent
			MinIndentSpace = string.gsub(editor:GetLine(curWhileLine), "^([ 	]*).*", "%1")
		end
		curWhileLine = curWhileLine + 1
	end
	return MinIndentSpace
end

-- ================================================== --
-- Define Keyword Build
-- ================================================== --

function OnSave()
	buildNames()
	Func_Set()
end

function OnSwitchFile()
	buildNames()
	Func_Set()
end

function OnOpen()
	buildNames()
	Func_Set()
end

function Func_Set()
	Define_Funcs = {}
	local update_state = false
	local text = editor:GetText()
	local ptrn = "([%w_]+)(%([^%)]*%))%s*{([^}]*)}"
	for func, param, command in string.gmatch(text, ptrn) do
		if string.gsub(func, "[wW][hH][iI][lL][eE]", "") ~= "" and keyInTable(Define_Funcs, func) == false then
			if string.find(command, "^%s*/%*") then
				local explan = string.gsub(string.match(command, "^%s*/%*[^\r\n]*[\r\n]*(.*)[\r\n]*%*/") or "", "%s*$", "")
				local indent = string.match(command, "^%s*\r?\n(%s*)")
				explan = string.gsub(string.gsub(string.gsub(explan, "^" .. indent, ""), "\n" .. indent, "\n"), "	", "    ")
				if string.find(explan, "^%s*$") == nil then
					explan = "\n" .. explan
				end
				Define_Funcs[func] = func .. param .. explan
			else
				Define_Funcs[func] = func .. param
			end
			update_state = true
		end
	end
	
	if update_state then
		local Funcs = ""
		local index = 0
		for word, explan in pairs(Define_Funcs) do
			if index == 10 then
				Funcs = Funcs .. "\\\n"
				index = 0
			end
			Funcs = Funcs .. string.lower(word) .. " "
			index = index + 1
		end
		local file = io.open(props['SciteUserHome'] .. "\\define_func.properties", "w")
		file:write("define.func=\\\n" .. Funcs)
		file:close()
	end
end

-- ================================================== --
-- OnMarginClick event - needed to set up breakpoints --
-- ================================================== --

function OnMarginClick(position, margin)
	-- This function only works with the AutoHotkey lexer
	if not InAHKLexer() then return false end
	
	if margin == 1 then
		if prepared then
			postmsg(4112, 1, editor:LineFromPosition(position))
		else
			line = editor:LineFromPosition(position)
			if editor:MarkerNext(line, 1024) == line then -- 1024 = BIT(10)
				editor:MarkerDelete(line, 10)
			else
				editor:MarkerAdd(line, 10)
			end
		end
		return true
	else
		return false
	end
end

-- =============================================== --
-- OnDwellStart event - used to implement hovering --
-- =============================================== --

function OnDwellStart(pos, s)
	if not prepared then return end
	if s ~= '' then
		pumpmsgstr(4112, 4, GetWord(pos))
	else
		pumpmsgstr(4112, 4, "")
	end
end

-- =========================================================== --
-- Get direction interface HWND function (used by the toolbar) --
-- =========================================================== --

function get_director_HWND()
	if prepared then return end
	
	if localizewin("scite4ahkToolbarTempWin") == false then
		print("Window doesn't exist.")
		return
	end
	
	pumpmsg(4099, 0, props['WindowID'])
end

-- ============== --
-- DBGp functions --
-- ============== --
-- The following are only reachable when an AutoHotkey script
-- is open so there's no need to check the lexer

function DBGp_Connect()
	if prepared then return end
	
	if localizewin("SciTEDebugStub") == false then
		print("Window doesn't exist.")
		return
	end
	
	-- Initialize
	pumpmsg(4112, 0, 0)
	prepared = true
	--SetMarkerColors()
	ClearAllMarkers()
	savedbk = enumBreakpoints()
end

function enumBreakpoints()
	line = editor:MarkerNext(0, 1024) -- 1024 = BIT(10)
	if line ~= -1 then
		i = 2
		tbl = { line }
		while true do
			line = editor:MarkerNext(line+1, 1024)
			if line == -1 then break end
			tbl[i] = line
			i = i + 1
		end
		return tbl
	end
	return nil
end

function DBGp_BkReset()
	if savedbk == nil then return end
	
	pumpmsg(4112, 5, 1)
	
	editor:MarkerDeleteAll(10)
	for i,v in ipairs(savedbk) do
		pumpmsg(4112, 1, v)
	end
	
	postmsg(4112, 5, 0)
	
	savedbk = nil
end

function DBGp_Disconnect()
	-- Deinitialize
	u = pumpmsg(4112, 255, 0)
	if u == 0 then return false end
	
	--editor.MarginSensitiveN[1] = false
	prepared = false
	ClearAllMarkers()
end

function DBGp_Inspect()
	if not prepared then return end
	pumpmsgstr(4112, 2, GetCurWord())
end

function DBGp_Run()
	if not prepared then return end
	postmsg(4112, 3, 1)
end

function DBGp_Stop()
	if not prepared then return end
	postmsg(4112, 3, 2)
end

function DBGp_Pause()
	if not prepared then return end
	postmsg(4112, 3, 3)
end

function DBGp_StepInto()
	if not prepared then return end
	postmsg(4112, 3, 4)
end

function DBGp_StepOver()
	if not prepared then return end
	postmsg(4112, 3, 5)
end

function DBGp_StepOut()
	if not prepared then return end
	postmsg(4112, 3, 6)
end

function DBGp_Stacktrace()
	if not prepared then return end
	postmsg(4112, 3, 7)
end

function DBGp_Varlist()
	if not prepared then return end
	postmsg(4112, 3, 8)
end

-- ============================================================ --
-- AutoIndent section - it implements AutoIndent for AutoHotkey --
-- ============================================================ --

-- Patterns for syntax matching
--local varCharPat = "[#_@%w%[%]%$%?]"
local varCharPat = "[#_@%w%$]"
local classCharPat = "[#_@%w%$%.]"
local ifPat = "[iI][fF]"
local altIfPat = ifPat.."%a+"
local whilePat = "[wW][hH][iI][lL][eE]"
local loopPat = "[lL][oO][oO][pP]"
local forPat = "[fF][oO][rR]"
local elsePat = "[eE][lL][sS][eE]"
local tryPat = "[tT][rR][yY]"
local catchPat = "[cC][aA][tT][cC][hH]"
local finallyPat = "[fF][iI][nN][aA][lL][lL][yY]"
local classPat = "[cC][lL][aA][sS][sS]"
local extendsPat = "[eE][xX][tT][eE][nN][dD][sS]"
local switchPat = "[sS][wW][iI][tT][cC][hH]"
local casePat = "[cC][aA][sS][eE]"
local defaultPat = "[dD][eE][fF][aA][uU][lL][tT]"

-- Functions to detect certain types of statements

function isOpenBraceLine(line)
	return string.find(line, "^%s*{") ~= nil
end

function isIfLine(line)
	return string.find(line, "^%s*"..ifPat.."%s+"..varCharPat) ~= nil
		or string.find(line, "^%s*"..ifPat.."%s*%(") ~= nil
		or string.find(line, "^%s*"..ifPat.."%s+!") ~= nil
		or string.find(line, "^%s*"..altIfPat.."%s*,") ~= nil
		or string.find(line, "^%s*"..altIfPat.."%s+") ~= nil
end

function isIfLineNoBraces(line)
	return isIfLine(line) and string.find(line, "{%s*$") == nil
end

function isTryLine(line)
	return string.find(line, "^%s*"..tryPat.."%s+$") ~= nil
end

function isTryLineAllowBraces(line)
	return isTryLine(line) or string.find(line, "^%s*"..tryPat.."%s*{%s*$") ~= nil
end

function isWhileLine(line)
	return string.find(line, "^%s*"..whilePat.."%s+") ~= nil
		or string.find(line, "^%s*"..whilePat.."%s*%(") ~= nil
end

function isLoopLine(line)
	return string.find(line, "^%s*"..loopPat.."%s*,") ~= nil
		or string.find(line, "^%s*"..loopPat.."%s+") ~= nil
		or string.find(line, "^%s*"..loopPat.."%s*{") ~= nil
end

function isForLine(line)
	return string.find(line, "^%s*"..forPat.."%s+"..varCharPat) ~= nil
end

function isLoopLineAllowBraces(line)
	return isLoopLine(line) or string.find(line, "^%s*"..loopPat.."%s*{%s*$") ~= nil
end

function isClassLine(line)
	return string.find(line, "^%s*"..classPat.."%s+"..classCharPat.."+%s*") ~= nil
		or string.find(line, "^%s*"..classPat.."%s+" ..classCharPat.."+%s*{") ~= nil
		or string.find(line, "^%s*"..classPat.."%s+" ..classCharPat.."+%s+"..extendsPat.."%s+"..classCharPat.."+%s*") ~= nil
		or string.find(line, "^%s*"..classPat.."%s+" ..classCharPat.."+%s+"..extendsPat.."%s+"..classCharPat.."+%s*{") ~= nil
end

function isClassLineAllowBraces(line)
	return isClassLine(line)
	or string.find(line, "^%s*"..classPat.."%s+" ..classCharPat.."+%s*{$") ~= nil
	or string.find(line, "^%s*"..classPat.."%s+" ..classCharPat.."+%s+"..extendsPat.."%s+"..classCharPat.."+%s*{$") ~= nil
end

function isSwitchLine(line)
	return string.find(line, "^%s*"..switchPat.."%s*%(") ~= nil
		or string.find(line, "^%s*"..switchPat.."%s+"..varCharPat) ~= nil
end

function isCaseLine(line)
	return string.find(line, "^%s*"..casePat.."%s+%S+") ~= nil
		or string.find(line, "^%s*"..defaultPat.."[\r]*[\n]+") ~= nil
end

function isCaseLineNotColon(line)
	if isCaseLine(line) then
		return not(string.find(line, ":%s") ~= nil)
	end
end

-- Minor annoyance: this way of doing ELSE detection makes the following
-- appear as an one-line indent statement:
-- else {commandWhichDoesNotInvolveIndention}
--
-- Examples:
-- else MsgBox
-- else var := value
--
-- Those cases seem rare enough not to attempt to fix them, the alternative
-- would be breaking "else if" indentation.

function isFunctionAllowBraces(prevLine, curLine)
	return string.find(curLine, "^%s*[%w_]+%([^%)]*%)%s*{%s*$") ~= nil
		or string.find(prevLine .. curLine, "^%s*[%w_]+%([^%)]*%)%s*{%s*$") ~= nil
end

function isElseLine(line)
	return string.find(line, "^%s*"..elsePat.."%s*") ~= nil
		or isElseWithClosingBrace(line)
end

function isElseWithClosingBrace(line)
	return string.find(line, "^%s*}%s*"..elsePat.."%s*") ~= nil
end

function isElseLineAllowBraces(line)
	return isElseLine(line) or isElseWithClosingBrace(line)
		or string.find(line, "^%s*"..elsePat.."%s*{%s*$") ~= nil
		or string.find(line, "^%s*}%s*"..elsePat.."%s*{%s*$") ~= nil
end

function isCatchLine(line)
	return string.find(line, "^%s*"..catchPat.."%s*$") ~= nil
		or string.find(line, "^%s*"..catchPat.."%s+"..varCharPat.."+%s*$") ~= nil
end

function isCatchAllowClosingBrace(line)
	return isCatchLine(line)
		or string.find(line, "^%s*}%s*"..catchPat.."%s*$") ~= nil
		or string.find(line, "^%s*}%s*"..catchPat.."%s+"..varCharPat.."+%s*$") ~= nil
end

function isCatchLineAllowBraces(line)
	return isCatchAllowClosingBrace(line)
		or string.find(line, "^%s*"..catchPat.."%s*{%s*$") ~= nil
		or string.find(line, "^%s*"..catchPat.."%s+"..varCharPat.."+%s*{%s*$") ~= nil
		or string.find(line, "^%s*}%s*"..catchPat.."%s*{%s*$") ~= nil
		or string.find(line, "^%s*}%s*"..catchPat.."%s+"..varCharPat.."+%s*{%s*$") ~= nil
end

function isFinallyLine(line)
	return string.find(line, "^%s*"..finallyPat.."%s*$") ~= nil
end

function isFinallyAllowClosingBrace(line)
	return isFinallyLine(line)
		or string.find(line, "^%s*}%s*"..finallyPat.."%s*$") ~= nil
end

function isFinallyAllowBraces(line)
	return isFinallyAllowClosingBrace(line)
		or string.find(line, "^%s*}%s*"..finallyPat.."%s*{%s*$") ~= nil
end

function isFunctionLine(line)
	if string.find(line, "^%s*[%w_]+%([^%)]*%)%s*$") ~= nil then
		local word = string.gsub(line, "^%s*([%w_]+).*", "%1")
		if string.find(word, "^" .. ifPat .."$") ~= nil or string.find(word, "^" .. whilePat .."$") ~= nil then
		return false else return true end
	end return false
end

function isSingleLineIndentStatement(line)
	return isIfLineNoBraces(line) or isElseLine(line) or isElseWithClosingBrace(line)
		or isWhileLine(line) or isForLine(line) or isLoopLine(line) or isClassLineAllowBraces(line)
		or isTryLine(line) or isCatchAllowClosingBrace(line) or isFinallyAllowClosingBrace(line)
end

function isIndentStatement(line)
	return isOpenBraceLine(line) or isIfLine(line) or isWhileLine(line) or isForLine(line)
		or isLoopLineAllowBraces(line) or isElseLineAllowBraces(line)
		or isTryLineAllowBraces(line) or isCatchLineAllowBraces(line) or isFinallyAllowBraces(line)
		or isCaseLine(line) or isClassLineAllowBraces(line)
end

function isStartBlockStatement(line)
	return isIfLine(line) or isWhileLine(line) or isLoopLine(line)  or isForLine(line)
		or isElseLine(line) or isElseWithClosingBrace(line) or isClassLine(line) or isClassLine(line)
		or isTryLine(line) or isCatchLineAllowBraces(line) or isFinallyAllowBraces(line)
end

-- This function is called when the user presses {Enter}
function AutoIndent_OnNewLine()
	local cmtLineStyle = IsAHKv2() and SCE_AHK2_COMMENTLINE or SCE_AHK_COMMENTLINE
	local cmtBlockStyle = IsAHKv2() and SCE_AHK2_COMMENTBLOCK or SCE_AHK_COMMENTBLOCK
	local prevprevPos = editor:LineFromPosition(editor.CurrentPos) - 2
	local prevPos = editor:LineFromPosition(editor.CurrentPos) - 1
	local prevLine = GetFilteredLine(prevPos, cmtLineStyle, cmtBlockStyle)
	local curPos = prevPos + 1
	local curLine = editor:GetLine(curPos)
	
	if curLine ~= nil and string.find(curLine, "^%s*[^%s]+") then return end
	
	if isCaseLine(prevLine) then
		local ThisPos = prevPos - 1
		local ThisLine = ""
		local curSpace = string.gsub(prevLine, "^([ 	]*).*", "%1")
		local linePos = editor:PositionFromLine(prevPos)
		local indentPos = string.find(prevLine, "[^ 	]") - 1
		local ThisSpace = ""
		while true do
			ThisLine = GetFilteredLine(ThisPos, cmtLineStyle, cmtBlockStyle)
			if isSwitchLine(ThisLine) then
				ThisSpace = string.gsub(ThisLine, "^([ 	]*).*", "%1") .. "	"
				break
			end
			ThisPos = ThisPos - 1
			if ThisPos <= 1 then
				break
			end
		end
		if curSpace ~= ThisSpace then
			editor:HomeExtend() editor:ReplaceSel(ThisSpace)
			editor:SetSel(linePos, linePos + indentPos) editor:ReplaceSel(ThisSpace) editor:LineDown()
		end
	end	
	if isIndentStatement(prevLine) then
		editor:Home() editor:Tab() editor:LineEnd()
		if isCaseLineNotColon(prevLine) then
			editor:LineUp() editor:LineEnd() editor:AddText(":") editor:LineDown()
		end
	elseif isSwitchLine(prevLine) then
		editor:AddText("{") editor:NewLine()
		local curPos = editor.CurrentPos
		editor:AddText("Case ") editor:NewLine() editor:AddText("}") editor:Home()
		editor:BackTab() editor:LineEnd() editor:GotoPos(curPos + 5)
	elseif prevprevPos >= 0 then
		local prevprevLine = GetFilteredLine(prevprevPos, cmtLineStyle, cmtBlockStyle)
		local reqLvl = editor.LineIndentation[prevprevPos] + editor.Indent
		local prevLvl = editor.LineIndentation[prevPos]
		local curLvl = editor.LineIndentation[curPos]
		if isSingleLineIndentStatement(prevprevLine) and prevLvl == reqLvl and curLvl == reqLvl then
			editor:Home()
			editor:BackTab()
			editor:LineEnd()
			return true
		end
	end
	return false
end

-- This function is called when the user presses {
function AutoIndent_OnOpeningBrace()
	local cmtLineStyle = IsAHKv2() and SCE_AHK2_COMMENTLINE or SCE_AHK_COMMENTLINE
	local cmtBlockStyle = IsAHKv2() and SCE_AHK2_COMMENTBLOCK or SCE_AHK_COMMENTBLOCK
	local prevPos = editor:LineFromPosition(editor.CurrentPos) - 1
	local curPos = prevPos+1
	if prevPos == -1 then return false end
	
	if editor.LineIndentation[curPos] == 0 then return false end
	
	local prevLine = GetFilteredLine(prevPos, cmtLineStyle, cmtBlockStyle)
	local curLine = GetFilteredLine(curPos, cmtLineStyle, cmtBlockStyle)
	
	if string.find(curLine, "^%s*{%s*$") and isStartBlockStatement(prevLine)
		and (editor.LineIndentation[curPos] > editor.LineIndentation[prevPos]) then
		editor:Home()
		editor:BackTab()
		editor:LineEnd()
	end
end

-- This function is called when the user presses }
function AutoIndent_OnClosingBrace()
	local cmtLineStyle = IsAHKv2() and SCE_AHK2_COMMENTLINE or SCE_AHK_COMMENTLINE
	local cmtBlockStyle = IsAHKv2() and SCE_AHK2_COMMENTBLOCK or SCE_AHK_COMMENTBLOCK
	local curPos = editor:LineFromPosition(editor.CurrentPos)
	local curLine = GetFilteredLine(curPos, cmtLineStyle, cmtBlockStyle)
	local prevPos = curPos - 1
	local prevprevPos = prevPos - 1
	local secondChance = false
	
	if curPos == 0 then return false end
	if editor.LineIndentation[curPos] == 0 then return false end
	
	if prevprevPos >= 0 then
		local prevprevLine = GetFilteredLine(prevprevPos, cmtLineStyle, cmtBlockStyle)
		local lowLvl = editor.LineIndentation[prevprevPos]
		local highLvl = lowLvl + editor.Indent
		local prevLvl = editor.LineIndentation[prevPos]
		local curLvl = editor.LineIndentation[curPos]
		if isSingleLineIndentStatement(prevprevLine) and prevLvl == highLvl and curLvl == lowLvl then
			secondChance = true
		end
	end
	
	if string.find(curLine, "^%s*}%s*$") and (editor.LineIndentation[curPos] >= editor.LineIndentation[prevPos] or secondChance) then
		editor:Home()
		editor:BackTab()
		editor:LineEnd()
	end
end

-- ====================== --
-- Script Backup Function --
-- ====================== --

-- this functions creates backups for the files

function OnBeforeSave(filename)
	-- This function only works with the AutoHotkey lexer
	if not InAHKLexer() then return false end
	
	if props['make.backup'] == "1" then
		local bkfile = string.gsub(string.gsub(filename, ":\\", ".."), "\\", ".")
							.. "_" .. os.date("%Y%m%d%H%M%S") .. ".bak"
		local bkpath = props['path.backup'] .. "\\"
		if not os.rename(filename, bkpath .. bkfile) then
			local file = io.open(filename, "r")
			if file ~= nil then
				local txt = file:read("*a")
				file = io.open(bkpath .. bkfile, "w")
				file:write(txt)
				file:close()
			end
		end
	end
end

-- ============= --
-- Open #Include --
-- ============= --

function OpenInclude()
	-- This function only works with the AutoHotkey lexer
	if not InAHKLexer() then return false end
	
	local CurrentLine = editor:GetLine(editor:LineFromPosition(editor.CurrentPos))
	if not string.find(CurrentLine, "^%s*%#[Ii][Nn][Cc][Ll][Uu][Dd][Ee]") then
		print("Not an include line!")
		return
	end
	local place = string.find(CurrentLine, "%#[Ii][Nn][Cc][Ll][Uu][Dd][Ee]")
	local IncFile = string.sub(CurrentLine, place + 8)
	if string.find(IncFile, "^[Aa][Gg][Aa][Ii][Nn]") then
		IncFile = string.sub(IncFile, 6)
	end
	IncFile = string.gsub(IncFile, "\r", "")  -- strip CR
	IncFile = string.gsub(IncFile, "\n", "")  -- strip LF
	IncFile = string.sub(IncFile, 2)          -- strip space at the beginning
	IncFile = string.gsub(IncFile, "*i ", "") -- strip *i option
	IncFile = string.gsub(IncFile, "*I ", "")
	-- Delete comments
	local cplace = string.find(IncFile, "%s*;")
	if cplace then
		IncFile = string.sub(IncFile, 1, cplace-1)
	end
	
	-- Delete spaces at the beginning and the end
	IncFile = string.gsub(IncFile, "^%s*", "")
	IncFile = string.gsub(IncFile, "%s*$", "")
	
	-- Replace variables
	IncFile = string.gsub(IncFile, "%%[Aa]_[Ss][Cc][Rr][Ii][Pp][Tt][Dd][Ii][Rr]%%", props['FileDir'])
	IncFile = string.gsub(IncFile, "%%[Aa]_[Ll][Ii][Nn][Ee][Ff][Ii][Ll][Ee]%%", props['FilePath'])
	
	a,b,IncLib = string.find(IncFile, "^<(.+)>$")
	
	if IncLib ~= nil then
	
		local IncLib2 = IncLib
		local RawIncLib = IncLib
		a,b,whatmatch = string.find(IncLib, "^(.-)_")
		if whatmatch ~= nil and whatmatch ~= "" then
			IncLib2 = whatmatch
		end
		IncLib = "\\"..IncLib..".ahk"
		IncLib2 = "\\"..IncLib2..".ahk"
		
		local GlobalLib = props['AutoHotkeyDir'].."\\Lib"
		local UserLib = props['SciteUserHome'].."\\..\\Lib"
		local LocalLib = props['FileDir'].."\\Lib"
		
		for i,LibDir in ipairs({GlobalLib, UserLib, LocalLib}) do
			if FileExists(LibDir..IncLib) then
				scite.Open(LibDir..IncLib)
				return
			elseif FileExists(LibDir..IncLib2) then
				scite.Open(LibDir..IncLib2)
				return
			end
		end
		
		print("Library not found! Specified: '"..RawIncLib.."'")
		
	elseif FileExists(IncFile) then
		scite.Open(IncFile)
	else
		print("File not found! Specified: '"..IncFile.."'")
	end
end

-- ================ --
-- Helper Functions --
-- ================ --

function InAHKLexer()
	return editor.Lexer == SCLEX_AHK1 or editor.Lexer == SCLEX_AHK2
end

function IsAHKv2()
	return editor.Lexer == SCLEX_AHK2
end

function GetWord(pos)
	from = editor:WordStartPosition(pos, true)
	to = editor:WordEndPosition(pos, true)
	return editor:textrange(from, to)
end

function GetCurWord()
	local word = editor:GetSelText()
	if word == "" then
		word = GetWord(editor.CurrentPos)
	end
	return word
end

function getPrevLinePos()
	local line = editor:LineFromPosition(editor.CurrentPos)-1
	local linepos = editor:PositionFromLine(line)
	local linetxt = editor:GetLine(line)
	return linepos + string.len(linetxt) - 1
end

function isInTable(table, elem)
	if table == null then return false end
	for k,i in ipairs(table) do
		if i == elem then
			return true
		end
	end
	return false
end

function GetFilteredLine(linen, style1, style2)
	unline = editor:GetLine(linen)
	lpos = editor:PositionFromLine(linen)
	q = 0
	for i = 0, string.len(unline)-1 do
		if(editor.StyleAt[lpos+i] == style1 or editor.StyleAt[lpos+i] == style2) then
			unline = unline:sub(1, i).."\000"..unline:sub(i+2)
		end
	end
	unline = string.gsub(unline, "%z", "")
	return unline
end

function SetMarkerColors()
	editor:MarkerDefine(10, 0)  -- breakpoint
	editor.MarkerBack[10] = 0x0000FF
	editor:MarkerDefine(11, 2)  -- current line arrow
	editor.MarkerBack[11] = 0xFFFF00
	editor:MarkerDefine(12, 22) -- current line highlighting
	editor.MarkerBack[12] = 0xFFFF00
	editor.MarkerAlpha[12] = 32
	editor:MarkerDefine(4, 2)
	editor.MarkerBack[4] = 0xFFFF00
end

function ClearAllMarkers()
	--editor:MarkerDeleteAll(10)
	editor:MarkerDeleteAll(11)
	editor:MarkerDeleteAll(12)
end

-- ======================= --
-- User Lua script loading --
-- ======================= --

function FileExists(file)
	local fobj = io.open(file, "r")
	if fobj then
		fobj:close()
		return true
	else
		return false
	end
end

function RegisterEvents(events)
	-- Code originally written by Lexikos (AutoComplete.lua)
	for evt, func in pairs(events) do
		local oldfunc = _G[evt]
		if oldfunc then
			_G[evt] = function(...) return func(...) or oldfunc(...) end
		else
			_G[evt] = func
		end
	end
end

-- Globals for extensions
g_SettingsDir = props['SciteUserHome'].."/Settings"

local jgslua = props['SciteUserHome'].."/UnofficialLua.lua"
local userlua = props['SciteUserHome'].."/UserLuaScript.lua"
local extlua = props['SciteUserHome'].."/_extensions.lua"
if FileExists(jgslua) then
	dofile(jgslua)
end
if FileExists(userlua) then
	dofile(userlua)
end
if FileExists(extlua) then
	dofile(extlua)
end

function str(char)
	if char > 0 then
		return (string.char(char))
	elseif char <= 0 then
		return ""
	end
end

function keyInTable(table, elem)
	if table == null then return false end
	for k,i in pairs(table) do
		if k == elem then
			return true
		end
	end
	return false
end