-- ahk.lua
-- =======

-- Part of SciTE4AutoHotkey
-- This file implements features specific to AutoHotkey in SciTE
-- Do NOT edit this file, use UserLuaScript.lua instead!

-- Functions:
--     AutoIndent for AutoHotkey
--     Some AutoComplete tweaks
--     Automatic backups
--     SciTEDebug.ahk DBGp debugger interface

local prepared = false
local savedbk = nil

-- ================================================== --
-- JANGOON's Unofficial Patch - Global variables
-- ================================================== --

-- Word Highlight
local HighlightLine = {}
local HighlightPos = 0

-- Realtime User Define Function 
local Define_Funcs = {}

-- Auto Indent
local UndoState = false

-- Auto Complete
local IGNORE_CASE = true
local MIN_PREFIX_LEN = tonumber(props['autocomplete.define.prefix'])
local MIN_IDENTIFIER_LEN = tonumber(props['autocomplete.define.identifier'])
local IDENTIFIER_PATTERNS = {"[%a_][%w_]+", "[%a_][%w_.]*[%w_]", "[%a_][%w_-]*[%w_]"}
local names = {}
local notempty = next

if IGNORE_CASE then
	normalize = string.lower
else
	normalize = function(word) return word end
end

function buildNames()
	names = {}
	local text = editor:GetText()
	for i, pattern in ipairs(IDENTIFIER_PATTERNS) do
		for word in string.gmatch(text, pattern) do
			if string.len(word) >= MIN_IDENTIFIER_LEN then
				names[word] = true
			end
		end
	end
end

-- ================================================== --
-- OnClear event - fired when SciTE changes documents --
-- ================================================== --

function OnClear()
	if not prepared then
		-- Remove the current line markers.
		ClearAllMarkers()
	end
	
	SetMarkerColors()
	editor.MarginSensitiveN[1] = true
end

-- ================================================== --
-- OnUpdateUI event
-- ================================================== --

function OnUpdateUI()
	if editor.TextLength == 0 then
		if props['FilePath'] ~= props['SciteUserHome'] .. "\\template.ahk" then
			local file, err = io.open(props['SciteUserHome'] .. "/template.ahk", "r")
			if file then
				local txt = file:read("*a")
				if txt ~= "" then editor:SetText(txt) end file:close()
			end
		end
	end

	local curPos = editor.CurrentPos
	RTcurChar = str(editor.CharAt[curPos])
	RTprevChar = str(editor.CharAt[curPos-1])
	
	if HighlightPos ~= curPos or editor:MarkerGet(editor:LineFromPosition(curPos)) == 0 then
		if editor:IndicatorValueAt(9, curPos) == 1 or editor:IndicatorValueAt(9, curPos - 1) == 1 then
			HighlightLine = {}
			local n = 1
			local limit = editor.TextLength
			while true do
				if editor:IndicatorValueAt(9, n) == 1 then
					local ThisLine = editor:LineFromPosition(n)
					HighlightLine[ThisLine] = true
					n = editor:PositionFromLine(ThisLine + 1)
				else
					n = n + 1
				end
				if n >= limit then
					break
				end
			end
			for i, _ in pairs(HighlightLine) do
				editor:MarkerAdd(i, 4)
			end
			HighlightPos = curPos
		else
			editor:MarkerDeleteAll(4)
			HighlightPos = 0
		end
	end
end

-- ====================================== --
-- OnChar event - needed by some features --
-- ====================================== --

function OnChar(curChar)
	local ignoreStylesTable = {
		[SCLEX_AHK1] = {SCE_AHK_COMMENTLINE, SCE_AHK_COMMENTBLOCK, SCE_AHK_STRING, SCE_AHK_ERROR, SCE_AHK_ESCAPE},
		[SCLEX_AHK2] = {SCE_AHK2_COMMENTLINE, SCE_AHK2_COMMENTBLOCK, SCE_AHK2_STRING, SCE_AHK2_ERROR, SCE_AHK2_ESCAPE},
	}
	
	-- This function should only run when the Editor pane is focused.
	if not editor.Focus then return false end
	-- This function only works with the AutoHotkey lexer
	if not InAHKLexer() then return false end

	local ignoreStyles = ignoreStylesTable[editor.Lexer]	
	local IgnoreChar = {"\n", "{", "}", "(", ")", "[", "]", ",", ".", "=", "'", '"'}

	if isInTable(IgnoreChar, curChar) then
		buildNames()
	end

	if curChar == "\n" then
		local prevStyle = editor.StyleAt[getPrevLinePos()]
		if not isInTable(ignoreStyles, prevStyle) then
			if not UndoState then
				editor:BeginUndoAction()
				AutoIndent_OnNewLine()
				editor:EndUndoAction()
				return true
			else
				return AutoIndent_OnNewLine()
			end
		end
	elseif curChar == "{" then
		if not UndoState then
			editor:BeginUndoAction()
		end
		local curStyle = editor.StyleAt[editor.CurrentPos-2]
		if not isInTable(ignoreStyles, curStyle) then
			AutoIndent_OnOpeningBrace()
			local curPos = editor.CurrentPos
			local curLine = editor:GetLine(editor:LineFromPosition(curPos))
			local prevLine = editor:GetLine(editor:LineFromPosition(curPos) - 1)
			if #Selected_Text == 0 then
				if string.find(curLine, ":=%s*{%s*$") then
					editor:AddText("}")
				else
					if isFunctionAllowBraces(prevLine, curLine) then
						editor:NewLine() editor:AddText("/* write your calltip here") editor:NewLine()
						editor:NewLine() editor:AddText("*/") editor:NewLine() curPos = editor.CurrentPos
						editor:NewLine() editor:Home() editor:BackTab() editor:AddText("}") Func_Set()
					elseif isStartBlockStatement(curLine) or isStartBlockStatement(prevLine .. curLine) then
						editor:NewLine() curPos = editor.CurrentPos editor:NewLine()
						if string.find(curLine, "^%s*{%s*$") then
							editor:BackTab()
						end
						editor:AddText("}")
					end
				end
				editor:GotoPos(curPos)
			else
				editor:HomeExtend()
				local BeforeText = editor:GetSelText()
				if string.find(BeforeText, ":=%s*{$") then
					editor:GotoPos(editor.Anchor)
					editor:AddText(Selected_Text .. "}")
				else
					Pairing("{", "}")
				end
			end
		end
		editor:EndUndoAction()
		UndoState = false
	elseif curChar == "}" then
		local curStyle = editor.StyleAt[editor.CurrentPos]
		if not isInTable(ignoreStyles, curStyle) then
			closeBrace("{", "}")
		end
		curStyle = editor.StyleAt[editor.CurrentPos-2]
		if not isInTable(ignoreStyles, curStyle) then
			AutoIndent_OnClosingBrace()
		end
	elseif curChar == "(" then
		local curStyle = editor.StyleAt[editor.CurrentPos-2]
		if not isInTable(ignoreStyles, curStyle) then
			Pairing("(", ")")
			scite.MenuCommand(IDM_SHOWCALLTIP)
			if editor:CallTipActive() == false then
				local curPos = editor.CurrentPos - 1
				local leftPos = editor:WordStartPosition(curPos)
				local curWord = editor:textrange(leftPos, curPos)
				if keyInTable(Define_Funcs, curWord) then
					editor:CallTipShow(leftPos, Define_Funcs[curWord])
				end
			end
		end
	elseif curChar == ")" then
		local curStyle = editor.StyleAt[editor.CurrentPos]
		if not isInTable(ignoreStyles, curStyle) then
			closeBrace("(", ")")
		end
	elseif curChar == "[" then
		local curStyle = editor.StyleAt[editor.CurrentPos-2]
		if not isInTable(ignoreStyles, curStyle) then
			Pairing("[", "]")
		end
	elseif curChar == "]" then
		local curStyle = editor.StyleAt[editor.CurrentPos]
		if not isInTable(ignoreStyles, curStyle) then
			closeBrace("[", "]")
		end
	elseif curChar == "," then
		local curStyle = editor.StyleAt[editor.CurrentPos]
		if not isInTable(ignoreStyles, curStyle) then
			editor:AddText(" ")
		end
	else
		local curStyle = editor.StyleAt[editor.CurrentPos-2]
		local pos = editor:WordStartPosition(editor.CurrentPos)
		
		-- Disable AutoComplete on comment/string/error/etc.
		if isInTable(ignoreStyles, curStyle) then
			-- ... but allow it in variable %dereferences% (which are set to 'error'
			-- when they are typed because of the missing closing percent sign.
			if not IsAHKv2() and curStyle == SCE_AHK_ERROR and editor.CharAt[pos-1] == 37
			  and not isInTable(ignoreStyles, editor.StyleAt[pos-1]) then
				return false
			end
			return CancelAutoComplete()
		end
		curStyle = editor.StyleAt[editor.CurrentPos]
		local prevChar = str(editor.CharAt[editor.CurrentPos - 2])
		if curChar ~= " " and prevChar == "," then
			if not isInTable(ignoreStyles, curStyle) then
				editor:DeleteBack()
				editor:AddText(" " .. curChar)
			end
		end
	end
	if not editor:AutoCActive() then
		editor.AutoCIgnoreCase = IGNORE_CASE
		local pos = editor.CurrentPos
		local startPos = editor:WordStartPosition(pos, true)
		local len = pos - startPos
		if len >= MIN_PREFIX_LEN then
			local prefix = editor:textrange(startPos, pos)
			local menuItems = {}
			for name, v in pairs(names) do
				if normalize(string.sub(name, 1, len)) == normalize(prefix) then 
					table.insert(menuItems, name)
				end
			end
			if notempty(menuItems) then
				table.sort(menuItems)
				editor:AutoCShow(len, table.concat(menuItems, " "))
			end
		end
	end	
	return false
end

function CancelAutoComplete()
	if editor:AutoCActive() then
		editor:AutoCCancel()
	end
	return true
end

function Pairing(BeforeChar, AfterChar)
	if #Selected_Text == 0 then
		local curChar = str(editor.CharAt[editor.CurrentPos])
		if string.find(curChar, "[%s%W]") or curChar == "" then
			editor:AddText(AfterChar) editor:GotoPos(editor.CurrentPos-1)
		end
	else
		if string.find(Selected_Text, "\n") or BeforeChar == "{" then
			editor:HomeExtend() editor:ReplaceSel(BeforeChar) editor:LineEndExtend() editor:NewLine()
			local curPos = editor.CurrentPos
			if BeforeChar == "{" then
				editor:AddText(string.gsub(Selected_LineText, "\n", "\n	") .. AfterChar)
			else
				editor:AddText("	" .. string.gsub(Selected_LineText, "\n", "\n	") .. AfterChar)
				curPos = curPos + 1
			end
			editor:Home() editor:BackTab() editor:LineUp() editor:LineEnd() editor:SetSel(editor.CurrentPos, curPos)
		else
			editor:AddText(Selected_Text .. AfterChar) editor:WordLeft() editor:GotoPos(Selected_EndPos)
			editor.Anchor = Selected_StartPos + 1
			editor.CurrentPos = Selected_EndPos + 1
		end
		editor:EndUndoAction()
	end
end

function closeBrace(openChar, closeChar)
	if str(editor.CharAt[editor.CurrentPos]) == closeChar then
		local ignoreStyles = {SCE_AHK_COMMENTLINE, SCE_AHK_COMMENTBLOCK, SCE_AHK_STRING, SCE_AHK_ERROR, SCE_AHK_ESCAPE}
		local curPos = editor.CurrentPos
		local curLine = editor:LineFromPosition(curPos)
		local startPos = editor:PositionFromLine(curLine)
		local EndPos = editor:PositionFromLine(curLine + 1)
		local thisPos = startPos
		local thisChar = ""
		local braceState = 0
		while true do
			if not isInTable(ignoreStyles, editor.StyleAt[thisPos]) then
				thisChar = str(editor.CharAt[thisPos])
				if thisChar == openChar then
					braceState = braceState + 1
				elseif thisChar == closeChar then
					braceState = braceState - 1
				end
			end
			thisPos = thisPos + 1
			if thisPos > EndPos then break end
		end
		if braceState == -1 then
			editor:DeleteBack() editor:GotoPos(curPos)
		end
	end
end

-- ====================================== --
-- OnKey event
-- ====================================== --

function OnKey(key)
	if key == 8 then
		local curPos = editor.CurrentPos
		if RTprevChar == "(" then
			DelEmptyBrace_Closer(")", curPos)
		elseif RTprevChar == ")" then
			DelEmptyBrace_Opener("(", curPos)
		elseif RTprevChar == "{" then
			DelEmptyBrace_Closer("}", curPos)
		elseif RTprevChar == "}" then
			DelEmptyBrace_Opener("{", curPos)
		elseif RTprevChar == "[" then
			DelEmptyBrace_Closer("]", curPos)
		elseif RTprevChar == "]" then
			DelEmptyBrace_Opener("[", curPos)
		elseif RTprevChar == "	" then
			local thisPos = curPos - 1
			local thisChar = 0
			local BraceState = false
			while true do
				thisChar = editor.CharAt[thisPos]
				if thisChar == 9 or thisChar == 10 or thisChar == 13 or thisChar == 32 then
					thisPos = thisPos - 1
					if thisPos == 0 then break end
				elseif thisChar == 123 then
					BraceState = true break
			else break end end
			if BraceState then
				local PairPos = editor:BraceMatch(thisPos, 0)
				if PairPos ~= -1 and string.find(editor:textrange(thisPos+ 1, PairPos), "^%s*$") then
					editor:DeleteRange(thisPos + 1, PairPos - thisPos)
				end
			end
		end
	elseif key == 57 or key == 219 then
		Selected_Text = editor:GetSelText()
		if #Selected_Text ~= 0 then
			editor:BeginUndoAction()
			UndoState = true
			Selected_StartPos = editor.Anchor
			Selected_EndPos = editor.CurrentPos
			if string.find(Selected_Text, "\n") then
				Selected_LineText = ""
				local LoopLine = editor:LineFromPosition(editor.SelectionStart)
				while LoopLine <= editor:LineFromPosition(editor.SelectionEnd) do
					Selected_LineText = Selected_LineText .. editor:GetLine(LoopLine)
					LoopLine = LoopLine + 1
				end
			else
				Selected_LineText = editor:GetLine(editor:LineFromPosition(Selected_StartPos))
			end
		end
	end
end

function DelEmptyBrace_Closer(char, curPos)
	if RTcurChar == char then
		editor:DeleteRange(curPos, 1)
	else
		local endPos = curPos
		local delRange = 2
		while true do
			local thisChar = str(editor.CharAt[endPos + 1])
			if string.find(thisChar, "%s") then
				endPos = endPos + 1
				delRange = delRange + 1
			else
				if thisChar == char then
					editor:DeleteRange(curPos, delRange)
				end
				break
			end
		end
	end
end

function DelEmptyBrace_Opener(char, curPos)
	local thisPos = curPos - 2
	if str(editor.CharAt[thisPos]) == "(" then
		editor:DeleteRange(thisPos, 1)
	else
		local delRange = 1
		while true do
			local thisChar = str(editor.CharAt[thisPos])
			if string.find(thisChar, "%s") then
				thisPos = thisPos - 1
				delRange = delRange + 1
			else
				if thisChar == char then
					editor:DeleteRange(thisPos, delRange)
				end
				break
			end
		end
	end
end

-- ================================================== --
-- Define Keyword Build
-- ================================================== --

function OnSave()
	buildNames()
	Func_Set()
end

function OnSwitchFile()
	buildNames()
	Func_Set()
end

function OnOpen()
	buildNames()
	Func_Set()
end

function Func_Set()
	Define_Funcs = {}
	local update_state = false
	local text = editor:GetText()
	local ptrn = "([%w_]+)(%([^%)]*%))%s*{([^}]*)}"
	for func, param, command in string.gmatch(text, ptrn) do
		if string.gsub(func, "[wW][hH][iI][lL][eE]", "") ~= "" and keyInTable(Define_Funcs, func) == false then
			if string.find(command, "^%s*/%*") then
				-- local explan = string.gsub(string.match(command, "^%s*/%*[^\r\n]*[\r\n]*(.*)[\r\n]*%*/"), "%s*$", "")
				local explan = string.gsub(string.match(command, "^%s*/%*[^\r\n]*[\r\n]*(.*)[\r\n]*%*/") or "", "%s*$", "")
				local indent = string.match(command, "^%s*\r?\n(%s*)")
				explan = string.gsub(string.gsub(string.gsub(explan, "^" .. indent, ""), "\n" .. indent, "\n"), "	", "    ")
				if string.find(explan, "^%s*$") == nil then
					explan = "\n" .. explan
				end
				Define_Funcs[func] = func .. param .. explan
			else
				Define_Funcs[func] = func .. param
			end
			update_state = true
		end
	end
	
	if update_state then
		local Funcs = ""
		local index = 0
		for word, explan in pairs(Define_Funcs) do
			if index == 10 then
				Funcs = Funcs .. "\\\n"
				index = 0
			end
			Funcs = Funcs .. string.lower(word) .. " "
			index = index + 1
		end
		local file, err = io.open(props['SciteUserHome'] .. "\\define_func.properties", "w")
		file:write("define.func=\\\n" .. Funcs)
		file:close()
	end
end

-- ================================================== --
-- OnMarginClick event - needed to set up breakpoints --
-- ================================================== --

function OnMarginClick(position, margin)
	-- This function only works with the AutoHotkey lexer
	if not InAHKLexer() then return false end
	
	if margin == 1 then
		if prepared then
			postmsg(4112, 1, editor:LineFromPosition(position))
		else
			line = editor:LineFromPosition(position)
			if editor:MarkerNext(line, 1024) == line then -- 1024 = BIT(10)
				editor:MarkerDelete(line, 10)
			else
				editor:MarkerAdd(line, 10)
			end
		end
		return true
	else
		return false
	end
end

-- =============================================== --
-- OnDwellStart event - used to implement hovering --
-- =============================================== --

function OnDwellStart(pos, s)
	if not prepared then return end
	if s ~= '' then
		pumpmsgstr(4112, 4, GetWord(pos))
	else
		pumpmsgstr(4112, 4, "")
	end
end

-- =========================================================== --
-- Get direction interface HWND function (used by the toolbar) --
-- =========================================================== --

function get_director_HWND()
	if prepared then return end
	
	if localizewin("scite4ahkToolbarTempWin") == false then
		print("Window doesn't exist.")
		return
	end
	
	pumpmsg(4099, 0, props['WindowID'])
end

-- ============== --
-- DBGp functions --
-- ============== --
-- The following are only reachable when an AutoHotkey script
-- is open so there's no need to check the lexer

function DBGp_Connect()
	if prepared then return end
	
	if localizewin("SciTEDebugStub") == false then
		print("Window doesn't exist.")
		return
	end
	
	-- Initialize
	pumpmsg(4112, 0, 0)
	prepared = true
	--SetMarkerColors()
	ClearAllMarkers()
	savedbk = enumBreakpoints()
end

function enumBreakpoints()
	line = editor:MarkerNext(0, 1024) -- 1024 = BIT(10)
	if line ~= -1 then
		i = 2
		tbl = { line }
		while true do
			line = editor:MarkerNext(line+1, 1024)
			if line == -1 then break end
			tbl[i] = line
			i = i + 1
		end
		return tbl
	end
	return nil
end

function DBGp_BkReset()
	if savedbk == nil then return end
	
	pumpmsg(4112, 5, 1)
	
	editor:MarkerDeleteAll(10)
	for i,v in ipairs(savedbk) do
		pumpmsg(4112, 1, v)
	end
	
	postmsg(4112, 5, 0)
	
	savedbk = nil
end

function DBGp_Disconnect()
	-- Deinitialize
	u = pumpmsg(4112, 255, 0)
	if u == 0 then return false end
	
	--editor.MarginSensitiveN[1] = false
	prepared = false
	ClearAllMarkers()
end

function DBGp_Inspect()
	if not prepared then return end
	pumpmsgstr(4112, 2, GetCurWord())
end

function DBGp_Run()
	if not prepared then return end
	postmsg(4112, 3, 1)
end

function DBGp_Stop()
	if not prepared then return end
	postmsg(4112, 3, 2)
end

function DBGp_Pause()
	if not prepared then return end
	postmsg(4112, 3, 3)
end

function DBGp_StepInto()
	if not prepared then return end
	postmsg(4112, 3, 4)
end

function DBGp_StepOver()
	if not prepared then return end
	postmsg(4112, 3, 5)
end

function DBGp_StepOut()
	if not prepared then return end
	postmsg(4112, 3, 6)
end

function DBGp_Stacktrace()
	if not prepared then return end
	postmsg(4112, 3, 7)
end

function DBGp_Varlist()
	if not prepared then return end
	postmsg(4112, 3, 8)
end

-- ============================================================ --
-- AutoIndent section - it implements AutoIndent for AutoHotkey --
-- ============================================================ --

-- Patterns for syntax matching
--local varCharPat = "[#_@%w%[%]%$%?]"
local varCharPat = "[#_@%w%$]"
local classCharPat = "[#_@%w%$%.]"
local ifPat = "[iI][fF]"
local altIfPat = ifPat.."%a+"
local whilePat = "[wW][hH][iI][lL][eE]"
local loopPat = "[lL][oO][oO][pP]"
local forPat = "[fF][oO][rR]"
local elsePat = "[eE][lL][sS][eE]"
local tryPat = "[tT][rR][yY]"
local catchPat = "[cC][aA][tT][cC][hH]"
local finallyPat = "[fF][iI][nN][aA][lL][lL][yY]"
local classPat = "[cC][lL][aA][sS][sS]"
local extendsPat = "[eE][xX][tT][eE][nN][dD][sS]"
local switchPat = "[sS][wW][iI][tT][cC][hH]"
local casePat = "[cC][aA][sS][eE]"
local defaultPat = "[dD][eE][fF][aA][uU][lL][tT]"

-- Functions to detect certain types of statements

function isOpenBraceLine(line)
	return string.find(line, "^%s*{") ~= nil
end

function isIfLine(line)
	return string.find(line, "^%s*"..ifPat.."%s+"..varCharPat) ~= nil
		or string.find(line, "^%s*"..ifPat.."%s*%(") ~= nil
		or string.find(line, "^%s*"..ifPat.."%s+!") ~= nil
		or string.find(line, "^%s*"..altIfPat.."%s*,") ~= nil
		or string.find(line, "^%s*"..altIfPat.."%s+") ~= nil
end

function isIfLineNoBraces(line)
	return isIfLine(line) and string.find(line, "{%s*$") == nil
end

function isTryLine(line)
	return string.find(line, "^%s*"..tryPat.."%s+$") ~= nil
end

function isTryLineAllowBraces(line)
	return isTryLine(line) or string.find(line, "^%s*"..tryPat.."%s*{%s*$") ~= nil
end

function isWhileLine(line)
	return string.find(line, "^%s*"..whilePat.."%s+") ~= nil
		or string.find(line, "^%s*"..whilePat.."%s*%(") ~= nil
end

function isLoopLine(line)
	return string.find(line, "^%s*"..loopPat.."%s*,") ~= nil
		or string.find(line, "^%s*"..loopPat.."%s+") ~= nil
		or string.find(line, "^%s*"..loopPat.."%s*{") ~= nil
end

function isForLine(line)
	return string.find(line, "^%s*"..forPat.."%s+"..varCharPat) ~= nil
end

function isLoopLineAllowBraces(line)
	return isLoopLine(line) or string.find(line, "^%s*"..loopPat.."%s*{%s*$") ~= nil
end

function isClassLine(line)
	return string.find(line, "^%s*"..classPat.."%s+"..classCharPat.."+%s*") ~= nil
		or string.find(line, "^%s*"..classPat.."%s+" ..classCharPat.."+%s*{") ~= nil
		or string.find(line, "^%s*"..classPat.."%s+" ..classCharPat.."+%s+"..extendsPat.."%s+"..classCharPat.."+%s*") ~= nil
		or string.find(line, "^%s*"..classPat.."%s+" ..classCharPat.."+%s+"..extendsPat.."%s+"..classCharPat.."+%s*{") ~= nil
end

function isClassLineAllowBraces(line)
	return isClassLine(line)
	or string.find(line, "^%s*"..classPat.."%s+" ..classCharPat.."+%s*{$") ~= nil
	or string.find(line, "^%s*"..classPat.."%s+" ..classCharPat.."+%s+"..extendsPat.."%s+"..classCharPat.."+%s*{$") ~= nil
end

function isSwitchLine(line)
	return string.find(line, "^%s*"..switchPat.."%s*%(") ~= nil
		or string.find(line, "^%s*"..switchPat.."%s+"..varCharPat) ~= nil
end

function isCaseLine(line)
	return string.find(line, "^%s*"..casePat.."%s+%S+") ~= nil
		or string.find(line, "^%s*"..defaultPat.."[\r]*[\n]+") ~= nil
end

function isCaseLineNotColon(line)
	if isCaseLine(line) then
		return not(string.find(line, ":%s") ~= nil)
	end
end

-- Minor annoyance: this way of doing ELSE detection makes the following
-- appear as an one-line indent statement:
-- else {commandWhichDoesNotInvolveIndention}
--
-- Examples:
-- else MsgBox
-- else var := value
--
-- Those cases seem rare enough not to attempt to fix them, the alternative
-- would be breaking "else if" indentation.

function isFunctionAllowBraces(prevLine, curLine)
	return string.find(curLine, "^%s*[%w_]+%([^%)]*%)%s*{%s*$") ~= nil
		or string.find(prevLine .. curLine, "^%s*[%w_]+%([^%)]*%)%s*{%s*$") ~= nil
end

function isElseLine(line)
	return string.find(line, "^%s*"..elsePat.."%s*") ~= nil
		or isElseWithClosingBrace(line)
end

function isElseWithClosingBrace(line)
	return string.find(line, "^%s*}%s*"..elsePat.."%s*") ~= nil
end

function isElseLineAllowBraces(line)
	return isElseLine(line) or isElseWithClosingBrace(line)
		or string.find(line, "^%s*"..elsePat.."%s*{%s*$") ~= nil
		or string.find(line, "^%s*}%s*"..elsePat.."%s*{%s*$") ~= nil
end

function isCatchLine(line)
	return string.find(line, "^%s*"..catchPat.."%s*$") ~= nil
		or string.find(line, "^%s*"..catchPat.."%s+"..varCharPat.."+%s*$") ~= nil
end

function isCatchAllowClosingBrace(line)
	return isCatchLine(line)
		or string.find(line, "^%s*}%s*"..catchPat.."%s*$") ~= nil
		or string.find(line, "^%s*}%s*"..catchPat.."%s+"..varCharPat.."+%s*$") ~= nil
end

function isCatchLineAllowBraces(line)
	return isCatchAllowClosingBrace(line)
		or string.find(line, "^%s*"..catchPat.."%s*{%s*$") ~= nil
		or string.find(line, "^%s*"..catchPat.."%s+"..varCharPat.."+%s*{%s*$") ~= nil
		or string.find(line, "^%s*}%s*"..catchPat.."%s*{%s*$") ~= nil
		or string.find(line, "^%s*}%s*"..catchPat.."%s+"..varCharPat.."+%s*{%s*$") ~= nil
end

function isFinallyLine(line)
	return string.find(line, "^%s*"..finallyPat.."%s*$") ~= nil
end

function isFinallyAllowClosingBrace(line)
	return isFinallyLine(line)
		or string.find(line, "^%s*}%s*"..finallyPat.."%s*$") ~= nil
end

function isFinallyAllowBraces(line)
	return isFinallyAllowClosingBrace(line)
		or string.find(line, "^%s*}%s*"..finallyPat.."%s*{%s*$") ~= nil
end

function isFuncDef(line)
	return string.find(line, "^%s*"..varCharPat.."+%(.*%)%s*{%s*$") ~= nil
end

function isSingleLineIndentStatement(line)
	return isIfLineNoBraces(line) or isElseLine(line) or isElseWithClosingBrace(line)
		or isWhileLine(line) or isForLine(line) or isLoopLine(line) or isClassLineAllowBraces(line)
		or isTryLine(line) or isCatchAllowClosingBrace(line) or isFinallyAllowClosingBrace(line)
end

function isIndentStatement(line)
	return isOpenBraceLine(line) or isIfLine(line) or isWhileLine(line) or isForLine(line)
		or isLoopLineAllowBraces(line) or isElseLineAllowBraces(line) or isFuncDef(line)
		or isTryLineAllowBraces(line) or isCatchLineAllowBraces(line) or isFinallyAllowBraces(line)
		or isCaseLine(line) or isClassLineAllowBraces(line)
end

function isStartBlockStatement(line)
	return isIfLine(line) or isWhileLine(line) or isLoopLine(line)  or isForLine(line)
		or isElseLine(line) or isElseWithClosingBrace(line) or isClassLine(line) or isClassLine(line)
		or isTryLine(line) or isCatchLineAllowBraces(line) or isFinallyAllowBraces(line)
end

-- This function is called when the user presses {Enter}
function AutoIndent_OnNewLine()
	local cmtLineStyle = IsAHKv2() and SCE_AHK2_COMMENTLINE or SCE_AHK_COMMENTLINE
	local cmtBlockStyle = IsAHKv2() and SCE_AHK2_COMMENTBLOCK or SCE_AHK_COMMENTBLOCK
	local prevprevPos = editor:LineFromPosition(editor.CurrentPos) - 2
	local prevPos = editor:LineFromPosition(editor.CurrentPos) - 1
	local prevLine = GetFilteredLine(prevPos, cmtLineStyle, cmtBlockStyle)
	local curPos = prevPos + 1
	local curLine = editor:GetLine(curPos)
	
	if curLine ~= nil and string.find(curLine, "^%s*[^%s]+") then return end
	
	if isCaseLine(prevLine) then
		local ThisPos = prevPos - 1
		local ThisLine = ""
		local curSpace = string.gsub(prevLine, "^([ 	]*).*", "%1")
		local linePos = editor:PositionFromLine(prevPos)
		local indentPos = string.find(prevLine, "[^ 	]") - 1
		local ThisSpace = ""
		while true do
			ThisLine = GetFilteredLine(ThisPos, cmtLineStyle, cmtBlockStyle)
			if isSwitchLine(ThisLine) then
				ThisSpace = string.gsub(ThisLine, "^([ 	]*).*", "%1") .. "	"
				break
			end
			ThisPos = ThisPos - 1
			if ThisPos <= 1 then
				break
			end
		end
		if curSpace ~= ThisSpace then
			editor:HomeExtend() editor:ReplaceSel(ThisSpace)
			editor:SetSel(linePos, linePos + indentPos) editor:ReplaceSel(ThisSpace) editor:LineDown()
		end
	end	
	if isIndentStatement(prevLine) then
		editor:Home() editor:Tab() editor:LineEnd()
		if isCaseLineNotColon(prevLine) then
			editor:LineUp() editor:LineEnd() editor:AddText(":") editor:LineDown()
		end
	elseif isSwitchLine(prevLine) then
		editor:AddText("{") editor:NewLine()
		local curPos = editor.CurrentPos
		editor:AddText("Case ") editor:NewLine() editor:AddText("}") editor:Home()
		editor:BackTab() editor:LineEnd() editor:GotoPos(curPos + 5)
	elseif prevprevPos >= 0 then
		local prevprevLine = GetFilteredLine(prevprevPos, cmtLineStyle, cmtBlockStyle)
		local reqLvl = editor.LineIndentation[prevprevPos] + editor.Indent
		local prevLvl = editor.LineIndentation[prevPos]
		local curLvl = editor.LineIndentation[curPos]
		if isSingleLineIndentStatement(prevprevLine) and prevLvl == reqLvl and curLvl == reqLvl then
			editor:Home()
			editor:BackTab()
			editor:LineEnd()
			return true
		end
	end
	return false
end

-- This function is called when the user presses {
function AutoIndent_OnOpeningBrace()
	local cmtLineStyle = IsAHKv2() and SCE_AHK2_COMMENTLINE or SCE_AHK_COMMENTLINE
	local cmtBlockStyle = IsAHKv2() and SCE_AHK2_COMMENTBLOCK or SCE_AHK_COMMENTBLOCK
	local prevPos = editor:LineFromPosition(editor.CurrentPos) - 1
	local curPos = prevPos+1
	if prevPos == -1 then return false end
	
	if editor.LineIndentation[curPos] == 0 then return false end
	
	local prevLine = GetFilteredLine(prevPos, cmtLineStyle, cmtBlockStyle)
	local curLine = GetFilteredLine(curPos, cmtLineStyle, cmtBlockStyle)
	
	if string.find(curLine, "^%s*{%s*$") and isStartBlockStatement(prevLine)
		and (editor.LineIndentation[curPos] > editor.LineIndentation[prevPos]) then
		editor:Home()
		editor:BackTab()
		editor:LineEnd()
	end
end

-- This function is called when the user presses }
function AutoIndent_OnClosingBrace()
	local cmtLineStyle = IsAHKv2() and SCE_AHK2_COMMENTLINE or SCE_AHK_COMMENTLINE
	local cmtBlockStyle = IsAHKv2() and SCE_AHK2_COMMENTBLOCK or SCE_AHK_COMMENTBLOCK
	local curPos = editor:LineFromPosition(editor.CurrentPos)
	local curLine = GetFilteredLine(curPos, cmtLineStyle, cmtBlockStyle)
	local prevPos = curPos - 1
	local prevprevPos = prevPos - 1
	local secondChance = false
	
	if curPos == 0 then return false end
	if editor.LineIndentation[curPos] == 0 then return false end
	
	if prevprevPos >= 0 then
		local prevprevLine = GetFilteredLine(prevprevPos, cmtLineStyle, cmtBlockStyle)
		local lowLvl = editor.LineIndentation[prevprevPos]
		local highLvl = lowLvl + editor.Indent
		local prevLvl = editor.LineIndentation[prevPos]
		local curLvl = editor.LineIndentation[curPos]
		if isSingleLineIndentStatement(prevprevLine) and prevLvl == highLvl and curLvl == lowLvl then
			secondChance = true
		end
	end
	
	if string.find(curLine, "^%s*}%s*$") and (editor.LineIndentation[curPos] >= editor.LineIndentation[prevPos] or secondChance) then
		editor:Home()
		editor:BackTab()
		editor:LineEnd()
	end
end

-- ====================== --
-- Script Backup Function --
-- ====================== --

-- this functions creates backups for the files

function OnBeforeSave(filename)
	-- This function only works with the AutoHotkey lexer
	if not InAHKLexer() then return false end
	
	if props['make.backup'] == "1" then
		local bkfile = string.gsub(string.gsub(filename, ":\\", ".."), "\\", ".")
							.. "_" .. os.date("%Y%m%d%H%M%S") .. ".bak"
		local bkpath = props['path.backup'] .. "\\"
		if not os.rename(filename, bkpath .. bkfile) then
			local file = io.open(filename, "r")
			if file then
				local txt = file:read("*a")
				file = io.open(bkpath .. bkfile, "w")
				file:write(txt)
				file:close()
			end
		end
	end
end

-- ============= --
-- Open #Include --
-- ============= --

function OpenInclude()
	-- This function only works with the AutoHotkey lexer
	if not InAHKLexer() then return false end
	
	local CurrentLine = editor:GetLine(editor:LineFromPosition(editor.CurrentPos))
	if not string.find(CurrentLine, "^%s*%#[Ii][Nn][Cc][Ll][Uu][Dd][Ee]") then
		print("Not an include line!")
		return
	end
	local place = string.find(CurrentLine, "%#[Ii][Nn][Cc][Ll][Uu][Dd][Ee]")
	local IncFile = string.sub(CurrentLine, place + 8)
	if string.find(IncFile, "^[Aa][Gg][Aa][Ii][Nn]") then
		IncFile = string.sub(IncFile, 6)
	end
	IncFile = string.gsub(IncFile, "\r", "")  -- strip CR
	IncFile = string.gsub(IncFile, "\n", "")  -- strip LF
	IncFile = string.sub(IncFile, 2)          -- strip space at the beginning
	IncFile = string.gsub(IncFile, "*i ", "") -- strip *i option
	IncFile = string.gsub(IncFile, "*I ", "")
	-- Delete comments
	local cplace = string.find(IncFile, "%s*;")
	if cplace then
		IncFile = string.sub(IncFile, 1, cplace-1)
	end
	
	-- Delete spaces at the beginning and the end
	IncFile = string.gsub(IncFile, "^%s*", "")
	IncFile = string.gsub(IncFile, "%s*$", "")
	
	-- Replace variables
	IncFile = string.gsub(IncFile, "%%[Aa]_[Ss][Cc][Rr][Ii][Pp][Tt][Dd][Ii][Rr]%%", props['FileDir'])
	IncFile = string.gsub(IncFile, "%%[Aa]_[Ll][Ii][Nn][Ee][Ff][Ii][Ll][Ee]%%", props['FilePath'])
	
	a,b,IncLib = string.find(IncFile, "^<(.+)>$")
	
	if IncLib ~= nil then
	
		local IncLib2 = IncLib
		local RawIncLib = IncLib
		a,b,whatmatch = string.find(IncLib, "^(.-)_")
		if whatmatch ~= nil and whatmatch ~= "" then
			IncLib2 = whatmatch
		end
		IncLib = "\\"..IncLib..".ahk"
		IncLib2 = "\\"..IncLib2..".ahk"
		
		local GlobalLib = props['AutoHotkeyDir'].."\\Lib"
		local UserLib = props['SciteUserHome'].."\\..\\Lib"
		local LocalLib = props['FileDir'].."\\Lib"
		
		for i,LibDir in ipairs({GlobalLib, UserLib, LocalLib}) do
			if FileExists(LibDir..IncLib) then
				scite.Open(LibDir..IncLib)
				return
			elseif FileExists(LibDir..IncLib2) then
				scite.Open(LibDir..IncLib2)
				return
			end
		end
		
		print("Library not found! Specified: '"..RawIncLib.."'")
		
	elseif FileExists(IncFile) then
		scite.Open(IncFile)
	else
		print("File not found! Specified: '"..IncFile.."'")
	end
end

-- ================ --
-- Helper Functions --
-- ================ --

function InAHKLexer()
	return editor.Lexer == SCLEX_AHK1 or editor.Lexer == SCLEX_AHK2
end

function IsAHKv2()
	return editor.Lexer == SCLEX_AHK2
end

function GetWord(pos)
	from = editor:WordStartPosition(pos, true)
	to = editor:WordEndPosition(pos, true)
	return editor:textrange(from, to)
end

function GetCurWord()
	local word = editor:GetSelText()
	if word == "" then
		word = GetWord(editor.CurrentPos)
	end
	return word
end

function getPrevLinePos()
	local line = editor:LineFromPosition(editor.CurrentPos)-1
	local linepos = editor:PositionFromLine(line)
	local linetxt = editor:GetLine(line)
	return linepos + string.len(linetxt) - 1
end

function isInTable(table, elem)
	if table == null then return false end
	for k,i in ipairs(table) do
		if i == elem then
			return true
		end
	end
	return false
end

function GetFilteredLine(linen, style1, style2)
	unline = editor:GetLine(linen)
	lpos = editor:PositionFromLine(linen)
	q = 0
	for i = 0, string.len(unline)-1 do
		if(editor.StyleAt[lpos+i] == style1 or editor.StyleAt[lpos+i] == style2) then
			unline = unline:sub(1, i).."\000"..unline:sub(i+2)
		end
	end
	unline = string.gsub(unline, "%z", "")
	return unline
end

function SetMarkerColors()
	editor:MarkerDefine(10, 0)  -- breakpoint
	editor.MarkerBack[10] = 0x0000FF
	editor:MarkerDefine(11, 2)  -- current line arrow
	editor.MarkerBack[11] = 0xFFFF00
	editor:MarkerDefine(12, 22) -- current line highlighting
	editor.MarkerBack[12] = 0xFFFF00
	editor.MarkerAlpha[12] = 32
	editor:MarkerDefine(4, 2)
	editor.MarkerBack[4] = 0xFFFF00
end

function ClearAllMarkers()
	--editor:MarkerDeleteAll(10)
	editor:MarkerDeleteAll(11)
	editor:MarkerDeleteAll(12)
end

-- ======================= --
-- User Lua script loading --
-- ======================= --

function FileExists(file)
	local fobj = io.open(file, "r")
	if fobj then
		fobj:close()
		return true
	else
		return false
	end
end

function RegisterEvents(events)
	-- Code originally written by Lexikos (AutoComplete.lua)
	for evt, func in pairs(events) do
		local oldfunc = _G[evt]
		if oldfunc then
			_G[evt] = function(...) return func(...) or oldfunc(...) end
		else
			_G[evt] = func
		end
	end
end

-- Globals for extensions
g_SettingsDir = props['SciteUserHome'].."/Settings"

local userlua = props['SciteUserHome'].."/UserLuaScript.lua"
local extlua = props['SciteUserHome'].."/_extensions.lua"
if FileExists(userlua) then
	dofile(userlua)
end
if FileExists(extlua) then
	dofile(extlua)
end

function str(char)
	if char > 0 then
		return (string.char(char))
	elseif char <= 0 then
		return ""
	end
end

function keyInTable(table, elem)
	if table == null then return false end
	for k,i in pairs(table) do
		if k == elem then
			return true
		end
	end
	return false
end